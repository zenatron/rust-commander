<!DOCTYPE html>
<html>
<head>
    <title>JSON Command Sender</title>
    <style>
        body { font-family: sans-serif; }
        .tab-container { display: flex; margin-bottom: 10px; }
        .tab { padding: 10px 15px; cursor: pointer; border: 1px solid #ccc; border-bottom: none; margin-right: 5px; background-color: #f1f1f1; }
        .tab.active { background-color: #ddd; }
        
        #mainInteractiveArea {
            display: flex;
            margin-top: 10px;
        }

        #tabContentContainer { /* Left panel */
            flex: 1; 
            max-height: 700px; 
            overflow-y: auto; 
            border-right: 1px solid #ccc; 
            padding-right: 10px; 
        }

        .tab-content { display: none; padding: 10px; }
        .tab-content.active { display: block; }
        .command-list { list-style-type: none; padding: 0; margin: 0; }
        .command-list li { padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee; }
        .command-list li:hover { background-color: #f9f9f9; }
        
        #formAndResponseArea { /* Right panel */
            flex: 1.5; 
            padding-left: 20px;
            display: flex;
            flex-direction: column;
        }

        #jsonDisplayAreasContainer {
            display: flex;
            flex-direction: column; /* Stack vertically */
            margin-bottom: 10px; /* Reduced margin */
        }
        #jsonDisplayAreasContainer > div {
            flex: 1;
            margin-bottom: 5px; /* Space between raw and filled JSON boxes */
        }
        #jsonDisplayAreasContainer > div:first-child {
            padding-right: 0; /* No padding needed when stacked */
        }
        #jsonDisplayAreasContainer > div:last-child {
            padding-left: 0; /* No padding needed when stacked */
        }

        pre#rawJsonDisplay, pre#filledJsonDisplay {
            width: 100%;
            box-sizing: border-box;
            min-height: 30px; /* Significantly reduced height for single line */
            height: auto; /* Allow height to adjust to content, for wrapping */
            font-family: monospace;
            font-size: 0.9em;
            border: 1px solid #ccc;
            padding: 5px;
            margin: 0;
            overflow-x: auto; /* Allow horizontal scroll for long single lines */
            overflow-y: hidden; /* Hide vertical scrollbar if content fits */
            white-space: pre; /* Prevent wrapping of the single JSON line */
            word-break: normal; /* Changed from break-all */
            background-color: white;
        }

        /* Highlight styles */
        .highlight-yellow { background-color: #ffed4a; }
        .highlight-green { background-color: #d2f8d2; /* PaleGreen variant */ }

        #variableInputsContainer {
            margin-top: 5px; 
            margin-bottom:10px; /* Reduced margin */
            padding: 8px;
            border: 1px solid #e0e0e0;
            background-color: #fdfdfd;
            max-height: 50px; /* Reduced max height */
            overflow-y: auto; 
            display: flex; 
            flex-wrap: wrap; /* Allow wrapping if they don't fit */
            gap: 10px; /* Space between variable groups */
        }
        .variable-input-group {
            margin-bottom: 0; /* Removed bottom margin as gap handles spacing */
            display: flex;
            align-items: center;
        }
        .variable-input-group label {
            display: inline-block;
            margin-right: 5px; /* Reduced margin */
            font-weight: normal; 
            font-size: 0.85em; /* Slightly smaller font */
            white-space: nowrap; /* Prevent label text from wrapping */
        }
        .variable-input-group input[type="text"] {
            width: 100px; /* Fixed smaller width, adjust as needed */
            padding: 4px; /* Reduced padding */
            border: 1px solid #ccc;
            font-size: 0.85em; /* Slightly smaller font */
        }

        #socketPathContainer { 
            display: none; /* Will be moved to header */
        }

        #buttonsContainer {
            display: none; /* Will be moved to header */
        }

        #header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: 20px;
        }

        #connectionStatus {
            font-weight: bold;
            padding: 4px 6px;
            border-radius: 4px;
            color: white;
        }
        .status-connected {
            background-color: green;
        }
        .status-disconnected {
            background-color: red;
        }

        #header-controls input[type="text"] {
            width: 200px; /* Adjust as needed */
            padding: 4px;
            border: 1px solid #ccc;
            font-size: 0.85em;
        }

        #header-controls button {
            padding: 4px 8px; /* Smaller padding for header buttons */
            font-size: 0.85em;
        }

        #messagesContainer { margin-top: 15px; }
        pre#messagesDisplay { 
            width: 100%;
            box-sizing: border-box;
            min-height: 450px; /* Increased height */
            height: 600px; /* Increased height */
            font-family: monospace;
            font-size: 0.9em;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            padding: 5px;
            margin: 0;
            overflow: auto;
            white-space: pre-wrap; /* Important for allowing spans to wrap if needed, but primarily for line breaks between spans */
        }
        .message-line { /* Common style for all message lines */
            display: block; /* Ensures each span takes a full line */
            padding: 2px 4px; /* Add a little padding within each message block */
            margin-bottom: 2px; /* Tiny space between message blocks */
            white-space: pre; /* Preserve internal spacing of the JSON string */
            overflow-x: auto; /* Add horizontal scroll for individual long messages */
            border-radius: 3px;
        }
        .message-sent {
            background-color: #a0e0fd;
            color: #000000;
        }
        .message-received {
            background-color: #a4fca3;
            color: #000000;
        }
    </style>
</head>
<body>

<div style="display: flex; align-items: center; justify-content: space-between;">
    <h2>Send JSON Command</h2>
    <div id="header-controls">
        <span id="connectionStatus">Disconnected</span>
        <input type="text" id="socket_path_header" placeholder="/tmp/my_unix_socket or localhost:5555" />
        <button type="button" id="connectButton_header">Connect</button>
        <button type="button" id="disconnectButton_header" style="display: none;">Disconnect</button>
    </div>
</div>

<div class="tab-container" id="tabContainer">
    <!-- Tabs will be inserted here -->
</div>

<div id="mainInteractiveArea">
    <div id="tabContentContainer">
        <!-- Tab content (command lists) will be inserted here by JS -->
    </div>

    <div id="formAndResponseArea">
        <div id="jsonDisplayAreasContainer">
            <div>
                <label for="rawJsonDisplay">Raw JSON (Template):</label>
                <pre id="rawJsonDisplay"></pre>
            </div>
            <div>
                <label for="filledJsonDisplay">Filled JSON (to Send):</label>
                <pre id="filledJsonDisplay"></pre>
                <button type="button" id="sendButton">Send</button>
            </div>
        </div>

        <div id="variableInputsContainer">
            <!-- Dynamic input fields will go here -->
        </div>

        <div id="response"></div>

        <div id="messagesContainer">
            <label for="messagesDisplay" style="font-weight: bold;">Messages:</label>
            <span class="message-sent" style="font-size: 0.85em;"> (sent)</span>
            <span class="message-received" style="font-size: 0.85em;"> (received)</span>
            <pre id="messagesDisplay"></pre> <!-- Replaced textarea with pre -->
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', async () => {
    const rawJsonDisplayElement = document.getElementById('rawJsonDisplay');
    const filledJsonDisplayElement = document.getElementById('filledJsonDisplay');
    const variableInputsContainer = document.getElementById('variableInputsContainer');
    const responseDiv = document.getElementById('response');
    const tabContainer = document.getElementById('tabContainer');
    const tabContentContainer = document.getElementById('tabContentContainer');
    const messagesDisplayElement = document.getElementById('messagesDisplay');

    // New header controls
    const socketPathInputHeader = document.getElementById('socket_path_header');
    const connectButtonHeader = document.getElementById('connectButton_header');
    const disconnectButtonHeader = document.getElementById('disconnectButton_header');
    const sendButtonHeader = document.getElementById('sendButton');
    const connectionStatusElement = document.getElementById('connectionStatus'); // New element

    let commandsData = {};
    let firstTabInitialized = false;
    let currentCommandTemplate = null;
    let currentFilledCommand = null;
    let persistentSocket = null;
    let activeVariablePaths = []; 

    // Function to update connection status display
    function updateConnectionStatus(isConnected) {
        if (isConnected) {
            connectionStatusElement.textContent = 'Connected';
            connectionStatusElement.classList.remove('status-disconnected');
            connectionStatusElement.classList.add('status-connected');
        } else {
            connectionStatusElement.textContent = 'Disconnected';
            connectionStatusElement.classList.remove('status-connected');
            connectionStatusElement.classList.add('status-disconnected');
        }
    }
    updateConnectionStatus(false); // Initial state

    try {
        const response = await fetch('commands.json');
        commandsData = await response.json();
    } catch (error) {
        console.error("Error fetching commands.json:", error);
        responseDiv.textContent = 'Error loading commands.';
        return;
    }

    function escapeHtml(unsafe) {
        return unsafe
             .replace(/&/g, "&amp;")
             .replace(/</g, "&lt;")
             .replace(/>/g, "&gt;")
             .replace(/\"/g, "&quot;")
             .replace(/\'/g, "&#039;");
    }

    function generateHighlightedHtml(jsonString, highlightInstructions) {
        if (!jsonString) return '';
        
        let line = jsonString; 
        let highlightClass = '';

        if (highlightInstructions.type === 'raw') {
            highlightClass = 'highlight-yellow';
        } else if (highlightInstructions.type === 'filled') {
            highlightClass = 'highlight-green';
        }

        if (!highlightClass || !line.includes('%')) {
            return escapeHtml(line); 
        }

        const parts = line.split('%');
        let processedLine = '';
        for (let i = 0; i < parts.length; i++) {
            processedLine += escapeHtml(parts[i]);
            if (i < parts.length - 1) { 
                processedLine += `<span class="${highlightClass}">%</span>`;
            }
        }
        return processedLine; 
    }

    const updateFilledJsonTextarea = () => {
        if (currentFilledCommand) {
            const filledJsonString = JSON.stringify(currentFilledCommand); 
            filledJsonDisplayElement.innerHTML = generateHighlightedHtml(filledJsonString, { type: 'filled' });
        } else {
            filledJsonDisplayElement.innerHTML = '';
        }
    };

    const generateVariableInputsUI = (templateObject) => {
        variableInputsContainer.innerHTML = ''; 
        activeVariablePaths = []; 
        let hasPlaceholders = false;

        const findPlaceholdersAndCreateInputs = (obj, currentPathParts = []) => {
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    const value = obj[key];
                    const newPathParts = [...currentPathParts, key];

                    if (typeof value === 'object' && value !== null) {
                        findPlaceholdersAndCreateInputs(value, newPathParts);
                    } else if (typeof value === 'string' && value.includes('%')) {
                        hasPlaceholders = true;
                        activeVariablePaths.push([...newPathParts]); 
                        const inputGroup = document.createElement('div');
                        inputGroup.classList.add('variable-input-group');

                        const label = document.createElement('label');
                        const labelText = newPathParts.length > 1 && newPathParts[0] === 'vars' ? 
                                          newPathParts.slice(1).join('.') : newPathParts.join('.');
                        label.textContent = `${labelText} (${value}):`;
                        label.title = `Path: ${newPathParts.join('.')}\\nOriginal: ${value}`;
                        
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.dataset.path = JSON.stringify(newPathParts);
                        
                        let currentVal = currentFilledCommand;
                        newPathParts.forEach(part => { currentVal = currentVal ? currentVal[part] : undefined; });
                        if (typeof currentVal === 'string' && !currentVal.includes('%')) {
                             input.value = currentVal;
                        }

                        input.addEventListener('input', (e) => {
                            const path = JSON.parse(e.target.dataset.path);
                            let targetObject = currentFilledCommand;
                            for (let i = 0; i < path.length - 1; i++) {
                                if (!targetObject[path[i]]) targetObject[path[i]] = {}; 
                                targetObject = targetObject[path[i]];
                            }
                            targetObject[path[path.length - 1]] = e.target.value;
                            updateFilledJsonTextarea();
                        });

                        inputGroup.appendChild(label);
                        inputGroup.appendChild(input);
                        variableInputsContainer.appendChild(inputGroup);
                    }
                }
            }
        };

        if (templateObject) {
            findPlaceholdersAndCreateInputs(templateObject);
        }
        if (!hasPlaceholders) {
            variableInputsContainer.innerHTML = '<p style="font-style: italic; color: #777; margin: 0; padding: 5px 0;">No variables to fill for this command.</p>';
        }
    };

    const topLevelKeys = Object.keys(commandsData);
    topLevelKeys.forEach((key) => {
        const nestedCommands = commandsData[key];
        if (Object.keys(nestedCommands).length === 0) {
            return; 
        }

        const tabButton = document.createElement('div');
        tabButton.classList.add('tab');
        tabButton.textContent = key;
        tabButton.dataset.tabKey = key;
        tabContainer.appendChild(tabButton);

        const tabContent = document.createElement('div');
        tabContent.classList.add('tab-content');
        tabContent.id = `tab-${key.replace(/\s+/g, '-')}`;
        tabContentContainer.appendChild(tabContent);

        const commandListUL = document.createElement('ul');
        commandListUL.classList.add('command-list');

        for (const commandName in nestedCommands) {
            const listItem = document.createElement('li');
            listItem.textContent = commandName;
            listItem.dataset.commandJsonString = JSON.stringify(nestedCommands[commandName]);
            
            listItem.addEventListener('click', (e) => {
                const cmdJsonString = e.target.dataset.commandJsonString;
                currentCommandTemplate = JSON.parse(cmdJsonString);
                currentFilledCommand = JSON.parse(cmdJsonString); 
                
                generateVariableInputsUI(currentCommandTemplate); 

                const rawJsonForDisplay = JSON.stringify(currentCommandTemplate); 
                rawJsonDisplayElement.innerHTML = generateHighlightedHtml(rawJsonForDisplay, { type: 'raw' });
                
                updateFilledJsonTextarea(); 
            });
            commandListUL.appendChild(listItem);
        }
        tabContent.appendChild(commandListUL);

        if (!firstTabInitialized) {
            tabButton.classList.add('active');
            tabContent.classList.add('active');
            firstTabInitialized = true;
        }

        tabButton.addEventListener('click', () => {
            document.querySelectorAll('.tab').forEach(tb => tb.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
            tabButton.classList.add('active');
            document.getElementById(`tab-${key.replace(/\s+/g, '-')}`).classList.add('active');
        });
    });

    // Helper function to append messages to the new messages display area
    function appendMessageToDisplay(messageText, type) {
        if (!messagesDisplayElement) return;

        const messageSpan = document.createElement('span');
        messageSpan.classList.add('message-line');
        if (type === 'sent') {
            messageSpan.classList.add('message-sent');
        } else if (type === 'received') {
            messageSpan.classList.add('message-received');
        }
        messageSpan.textContent = messageText;
        
        messagesDisplayElement.appendChild(messageSpan);
        messagesDisplayElement.scrollTop = messagesDisplayElement.scrollHeight; // Auto-scroll
    }

    sendButtonHeader.addEventListener('click', async () => {
        if (!currentFilledCommand) { 
            responseDiv.textContent = 'No command selected or filled.';
            return;
        }
        
        const commandToSendString = JSON.stringify(currentFilledCommand); // Single line
        appendMessageToDisplay(`${commandToSendString}`, 'sent'); // Append sent message

        responseDiv.textContent = 'Sending command...';

        try {
            const res = await fetch('/send-command', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ json_command: currentFilledCommand }) 
            });
            const text = await res.text();
            if (res.ok) {
                responseDiv.textContent = `Command sent successfully. Server says: ${text}`;
            } else {
                responseDiv.textContent = `Error sending command. Server says: ${text}`;
            }
        } catch (error) {
            console.error("Error sending command:", error);
            responseDiv.textContent = `Error: ${error.message}`;
        }
    });

    connectButtonHeader.addEventListener('click', async () => {
        const socketPath = socketPathInputHeader.value;
        if (!socketPath) {
            responseDiv.textContent = 'Socket path is empty for connection.';
            return;
        }

        responseDiv.textContent = 'Connecting to TCP socket...';
        connectButtonHeader.disabled = true;
        disconnectButtonHeader.disabled = true;
        updateConnectionStatus(false); // Show disconnected initially or while trying

        try {
            const res = await fetch('/connect', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ socket_path: socketPath })
            });
            const text = await res.text();
            if (res.ok) {
                responseDiv.textContent = `TCP Connection: ${text}. Now establishing WebSocket for incoming messages...`;
                establishWebSocket(socketPath);
                // Status updated in establishWebSocket onopen
                connectButtonHeader.style.display = 'none';
                disconnectButtonHeader.style.display = 'inline-block';
                disconnectButtonHeader.disabled = false;
                socketPathInputHeader.disabled = true;
            } else {
                responseDiv.textContent = `Error connecting to TCP: ${text}`;
                connectButtonHeader.disabled = false;
                disconnectButtonHeader.disabled = true;
                updateConnectionStatus(false);
            }
        } catch (error) {
            console.error("Error connecting to TCP socket:", error);
            responseDiv.textContent = `Error: ${error.message}`;
            connectButtonHeader.disabled = false;
            disconnectButtonHeader.disabled = true;
            updateConnectionStatus(false);
        }
    });

    disconnectButtonHeader.addEventListener('click', async () => {
        responseDiv.textContent = 'Disconnecting...';
        disconnectButtonHeader.disabled = true;
        connectButtonHeader.disabled = true;
        // updateConnectionStatus(false); // Status will be updated in WebSocket onclose

        try {
            const res = await fetch('/disconnect', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
            });
            const text = await res.text();
            if (res.ok) {
                responseDiv.textContent = `TCP Disconnection: ${text}. Closing WebSocket.`;
                if (persistentSocket && persistentSocket.readyState === WebSocket.OPEN) {
                    persistentSocket.close(1000, "User initiated disconnect");
                }
                // updateConnectionStatus(false); // WebSocket onclose will handle this
            } else {
                responseDiv.textContent = `Error disconnecting TCP: ${text}`;
                // If disconnect fails, buttons might need re-enabling or status re-evaluation
                // For now, assume onclose will eventually fire or user retries
                disconnectButtonHeader.disabled = false; // Re-enable if server-side disconnect failed
                connectButtonHeader.disabled = false; // Potentially allow retry or new connection
            }
        } catch (error) {
            console.error("Error disconnecting TCP socket:", error);
            responseDiv.textContent = `Error during TCP disconnect: ${error.message}`;
            // Similar to above, re-enable buttons if the fetch itself failed
            disconnectButtonHeader.disabled = false;
            connectButtonHeader.disabled = false;
            updateConnectionStatus(false); // Explicitly set to disconnected on fetch error
        }
    });

    function establishWebSocket(socketPathForContext) {
        if (persistentSocket && (persistentSocket.readyState === WebSocket.OPEN || persistentSocket.readyState === WebSocket.CONNECTING)) {
            console.log("WebSocket already open or connecting.");
            return;
        }
        
        messagesDisplayElement.innerHTML = ''; // Clear previous messages on new connection

        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${wsProtocol}//${window.location.host}/ws`;

        persistentSocket = new WebSocket(wsUrl);
        responseDiv.textContent = 'WebSocket connecting...';
        // updateConnectionStatus(false); // Already disconnected or trying

        persistentSocket.onopen = () => {
            responseDiv.textContent = `WebSocket connected. Listening for incoming messages.`;
            disconnectButtonHeader.disabled = false;
            updateConnectionStatus(true);
        };

        persistentSocket.onmessage = (event) => {
            console.log("WS Message:", event.data);
            let messageContent = event.data;
            let messageType = 'received'; // Default for actual messages

            if (event.data === "TCP_CONNECTION_CLOSED" || event.data === "TCP_CONNECTION_CLOSED_OR_STREAM_ENDED") {
                messageContent = "--- TCP Connection Closed by Server ---";
                messageType = 'system'; // Or some other class for neutral styling
                responseDiv.textContent = "TCP Connection was closed by the server. WebSocket also closing.";
                if (persistentSocket && persistentSocket.readyState === WebSocket.OPEN) {
                    persistentSocket.close(1000, "TCP connection closed by peer");
                }
            } else if (event.data.startsWith("TCP_READ_ERROR:")) {
                messageContent = `--- TCP Read Error: ${event.data.substring("TCP_READ_ERROR:".length)} ---`;
                messageType = 'system';
                responseDiv.textContent = "TCP Read Error. WebSocket also closing.";
                 if (persistentSocket && persistentSocket.readyState === WebSocket.OPEN) {
                    persistentSocket.close(1000, "TCP read error");
                }
            }
            else {
                try {
                    const jsonData = JSON.parse(event.data);
                    messageContent = `${JSON.stringify(jsonData)}`;
                } catch (e) {
                    messageContent = `not JSON?: ${event.data}`; // If not JSON, display raw, add prefix
                }
            }
            appendMessageToDisplay(messageContent, messageType);
        };

        persistentSocket.onclose = (event) => {
            let reason = '';
            if (event.code === 1000) {
                reason = "Normal closure";
            } else if (event.code === 1001) {
                reason = "Endpoint going away";
            } else if (event.code === 1006) {
                reason = "Connection closed abnormally";
            } else {
                reason = `Unknown reason (code: ${event.code}, reason: ${event.reason || 'N/A'})`;
            }
            const currentResponse = responseDiv.textContent;
            if (!currentResponse.includes("TCP Disconnection")) {
                 responseDiv.textContent = `WebSocket disconnected. Reason: ${reason}`;
            }
            connectButtonHeader.style.display = 'inline-block';
            disconnectButtonHeader.style.display = 'none';
            socketPathInputHeader.disabled = false;
            connectButtonHeader.disabled = false;
            persistentSocket = null;
            updateConnectionStatus(false);
            console.log("WebSocket connection closed:", reason);
        };

        persistentSocket.onerror = (error) => {
            console.error("WebSocket Error:", error);
            // responseDiv.textContent = 'WebSocket error. See console.'; // Optionally update responseDiv
            updateConnectionStatus(false); // Assume disconnected on error
        };
    }
});
</script>
</body>
</html>